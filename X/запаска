<?php


function runIncrementalScan($pdo) {
    // Увеличиваем время выполнения, если папок много
    set_time_limit(1200);
    ini_set('memory_limit', '512M');

    $stats = ['new' => 0, 'moved' => 0, 'deleted' => 0, 'updated' => 0];

    // ============================================
    // 0. СОЗДАЁМ ЗАПИСЬ О НАЧАЛЕ СКАНИРОВАНИЯ
    // ============================================
    $scanStartStmt = $pdo->prepare("
        INSERT INTO scan_history 
        (scan_path_id, scan_started_at, status) 
        VALUES (NULL, CURRENT_TIMESTAMP, 'running')
        RETURNING id
    ");
    $scanStartStmt->execute();
    $currentScanId = $scanStartStmt->fetchColumn();

    try {
        // ============================================
        // 1. ПОЛУЧАЕМ ПУТИ ДЛЯ СКАНИРОВАНИЯ
        // ============================================
        $stmt = $pdo->query("SELECT id, path FROM scan_paths");
        $roots = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if (empty($roots)) {
            // Обновляем статус скана как ошибка
            $pdo->prepare("UPDATE scan_history SET status = 'error', error_message = ?, scan_finished_at = CURRENT_TIMESTAMP WHERE id = ?")
                ->execute(['Добавьте пути в админке', $currentScanId]);
            
            return ["status" => "error", "message" => "Добавьте пути в админке"];
        }

        // ============================================
        // СБРОС ФЛАГОВ ПЕРЕД СКАНИРОВАНИЕМ
        // ============================================
        // Получаем ID всех активных путей
        $activePathIds = array_column($roots, 'id');
        $placeholders = implode(',', array_fill(0, count($activePathIds), '?'));
        
        // Помечаем файлы из активных путей И файлы с отключенными источниками
        $resetStmt = $pdo->prepare("
            UPDATE files 
            SET temp_found = false 
            WHERE scan_path_id IN ($placeholders) 
            OR scan_path_id IS NULL 
            OR file_status = 'source_off'
        ");
        $resetStmt->execute($activePathIds);

        // ============================================
        // 2. СКАНИРОВАНИЕ (Фаза 1: Сбор данных)
        // ============================================
        
        // Временный массив для потенциально новых файлов
        $pending_new = [];
        
        foreach ($roots as $rootData) {
            $root = $rootData['path'];
            $scanPathId = $rootData['id'];

            if (!is_dir($root)) {
                error_log("Путь не существует или недоступен: $root");
                continue;
            }

            try {
                $dir_iterator = new RecursiveDirectoryIterator($root, RecursiveDirectoryIterator::SKIP_DOTS);
                $iterator = new RecursiveIteratorIterator($dir_iterator, RecursiveIteratorIterator::LEAVES_ONLY, RecursiveIteratorIterator::CATCH_GET_CHILD);

                foreach ($iterator as $info) {
                    // if (!$info->isReadable() || $info->isDir()) continue;
                    if (!$info->isReadable()) continue;

                    $path = str_replace('\\', '/', $info->getPathname());
                    $name = $info->getFilename();
                    $size = $info->getSize();
                    
                    // Получаем расширение файла
                    $extension = strtolower(pathinfo($name, PATHINFO_EXTENSION));

                    // ПРОВЕРКА: Есть ли файл по этому пути?
                    $checkStmt = $pdo->prepare("SELECT id, file_size, scan_path_id, file_status FROM files WHERE file_path = ?");
                    $checkStmt->execute([$path]);
                    $existing = $checkStmt->fetch(PDO::FETCH_ASSOC);

                    if ($existing) {
                        // --- ФАЙЛ УЖЕ ЕСТЬ ПО ЭТОМУ ПУТИ ---
                        $updateFields = ["temp_found = true"];
                        $params = [];
                        
                        // Проверяем изменился ли размер
                        if ($existing['file_size'] != $size) {
                            $updateFields[] = "file_size = ?";
                            $updateFields[] = "file_status = 'updated'";
                            $updateFields[] = "updated_at = CURRENT_TIMESTAMP";
                            $params[] = $size;
                            
                            // Записываем в историю изменений
                            $logUpdate = $pdo->prepare("
                                INSERT INTO file_changes (scan_history_id, file_id, change_type, old_path, new_path, details)
                                VALUES (?, ?, 'updated', ?, ?, ?::jsonb)
                            ");
                            $logUpdate->execute([
                                $currentScanId,
                                $existing['id'],
                                $path,
                                $path,
                                json_encode(['old_size' => $existing['file_size'], 'new_size' => $size])
                            ]);
                            
                            $stats['updated']++;
                        } else {
                            // Размер не изменился
                            // Возвращаем в 'active' все статусы, КРОМЕ 'active'
                            if ($existing['file_status'] !== 'active') {
                                $updateFields[] = "file_status = 'active'";
                                $updateFields[] = "updated_at = CURRENT_TIMESTAMP";
                            }
                        }

                        $params[] = $existing['id'];
                        $sql = "UPDATE files SET " . implode(", ", $updateFields) . " WHERE id = ?";
                        $pdo->prepare($sql)->execute($params);

                    } else {
                        // --- ФАЙЛА НЕТ ПО ЭТОМУ ПУТИ ---
                        // Складываем во временный массив для последующего анализа
                        $fileHash = hash_file('sha256', $path);

                        $pending_new[] = [
                            'scan_path_id' => $scanPathId,
                            'name' => $name,
                            'path' => $path,
                            'extension' => $extension,
                            'size' => $size,
                            'hash' => $fileHash
                        ];
                    }
                }
            } catch (Exception $e) {
                error_log("Ошибка при сканировании пути $root: " . $e->getMessage());
                continue;
            }
        }

        // ============================================
        // 2.5 АНАЛИЗ ПЕРЕМЕЩЕНИЙ (Фаза 2: После сканирования)
        // ============================================
        
        foreach ($pending_new as $item) {
            // Ищем потерянный файл с таким же именем и размером = нет - хэшом!
            $moveStmt = $pdo->prepare("
                SELECT id, file_path, scan_path_id, file_status FROM files 
                WHERE file_hash = ? 
                AND (temp_found = false OR scan_path_id IS NULL OR file_status = 'source_off')
                LIMIT 1
            ");
            $moveStmt->execute([$item['hash']]);
            $lostFile = $moveStmt->fetch(PDO::FETCH_ASSOC);

            if ($lostFile) {
                // --- ФАЙЛ ПЕРЕМЕСТИЛСЯ ИЛИ ИСТОЧНИК БЫЛ ВОССТАНОВЛЕН ---
                $oldPath = $lostFile['file_path'];
                $oldStatus = $lostFile['file_status'];

                // Определяем новый статус
                if ($oldStatus === 'source_off' || $lostFile['scan_path_id'] === null) {
                    // Источник был отключен, теперь включён обратно
                    $newStatus = 'active';
                    $changeType = 'restored';
                } else {
                    // Обычное перемещение
                    $newStatus = 'moved';
                    $changeType = 'moved';
                }

                // Обновляем файл
                $updMove = $pdo->prepare("
                    UPDATE files SET 
                        file_path = ?,
                        file_name = ?,
                        file_hash = ?,
                        scan_path_id = ?,
                        file_status = ?,
                        temp_found = true,
                        updated_at = CURRENT_TIMESTAMP 
                    WHERE id = ?
                ");
                $updMove->execute([$item['path'], $item['name'], $item['hash'], $item['scan_path_id'], $newStatus, $lostFile['id']]);

                // Записываем в историю
                $logMove = $pdo->prepare("
                    INSERT INTO file_changes (scan_history_id, file_id, change_type, old_path, new_path)
                    VALUES (?, ?, ?, ?, ?)
                ");
                $logMove->execute([
                    $currentScanId,
                    $lostFile['id'],
                    $changeType,
                    $oldPath,
                    $item['path']
                ]);

                if ($changeType === 'moved') {
                    $stats['moved']++;
                }
                
            } else {
                // --- НОВЫЙ ФАЙЛ ---
                $insStmt = $pdo->prepare("
                    INSERT INTO files (scan_path_id, file_name, file_path, file_extension, file_size, file_hash, file_status, temp_found)
                    VALUES (?, ?, ?, ?, ?, ?, 'new', true)
                    RETURNING id
                ");
                $insStmt->execute([
                    $item['scan_path_id'], 
                    $item['name'], 
                    $item['path'], 
                    $item['extension'], 
                    $item['size'],
                    $item['hash']
                ]);
                $newFileId = $insStmt->fetchColumn();
                
                // Записываем в историю
                // $logNew = $pdo->prepare("
                //     INSERT INTO file_changes (scan_history_id, file_id, change_type, new_path)
                //     VALUES (?, ?, 'added', ?)
                // ");
                // $logNew->execute([$currentScanId, $newFileId, $item['path']]);
                
                $stats['new']++;
            }
        }

        // ============================================
        // 3. ФИНАЛИЗАЦИЯ (Удаленные файлы)
        // ============================================
        
        // Получаем список удалённых файлов из АКТИВНЫХ путей
        $stmtDeleted = $pdo->prepare("
            SELECT id, file_path FROM files 
            WHERE temp_found = false 

            AND file_status NOT IN ('deleted', 'source_off')
            AND scan_path_id IN ($placeholders)
        ");
        $stmtDeleted->execute($activePathIds);
        $deletedFiles = $stmtDeleted->fetchAll(PDO::FETCH_ASSOC);
        
        $stats['deleted'] = count($deletedFiles);

        // Логируем каждый удалённый файл
        if ($stats['deleted'] > 0) {
            $logDelete = $pdo->prepare("
                INSERT INTO file_changes (scan_history_id, file_id, change_type, old_path)
                VALUES (?, ?, 'deleted', ?)
            ");
            
            foreach ($deletedFiles as $deletedFile) {
                $logDelete->execute([
                    $currentScanId,
                    $deletedFile['id'],
                    $deletedFile['file_path']
                ]);
            }
        }

        // Массово обновляем статус для всех пропавших файлов из активных путей
        $updateDeletedStmt = $pdo->prepare("
            UPDATE files 
            SET file_status = 'deleted', updated_at = CURRENT_TIMESTAMP
            WHERE temp_found = false 
            AND file_status != 'deleted'
            AND scan_path_id IN ($placeholders)
        ");
        $updateDeletedStmt->execute($activePathIds);

        // Помечаем файлы, чьи пути были удалены из админки
        // НО только если они ещё не были помечены как source_off
        $pdo->exec("
            UPDATE files 
            SET file_status = 'source_off', updated_at = CURRENT_TIMESTAMP
            WHERE file_status != 'source_off'
            AND (scan_path_id IS NULL OR scan_path_id NOT IN (SELECT id FROM scan_paths))
        ");

        // ============================================
        // 4. ОБНОВЛЯЕМ ЗАПИСЬ О СКАНИРОВАНИИ
        // ============================================
        $updateScanStmt = $pdo->prepare("
            UPDATE scan_history SET 
                scan_finished_at = CURRENT_TIMESTAMP,
                files_found = (SELECT COUNT(*) FROM files WHERE temp_found = true),
                files_added = ?,
                files_updated = ?,
                files_deleted = ?,
                files_moved = ?,
                status = 'success'
            WHERE id = ?

        ");


        // $roots = $rootData['path']; прикол в том что у нас может быть несколько айди - хз как это вписать в бд
        // $scanPathId = $rootData['id'];
        // scan_path_id = ?,

        $updateScanStmt->execute([
            // $scanPathId,
            $stats['new'],
            $stats['updated'],
            $stats['deleted'],
            $stats['moved'],
            $currentScanId
        ]);


        // тут ласт скан в скан патче таблице обновим время
        $stmt2 = $pdo->prepare("UPDATE scan_paths SET last_scanned_at = CURRENT_TIMESTAMP");
        $stmt2->execute();


        // Сохраняем время скана в сессию
        $_SESSION['last_scan_time'] = date("H:i:s");

        return [
            'status' => 'success',
            'message' => 'Сканирование завершено',
            'stats' => $stats,
            'scan_id' => $currentScanId
        ];

    } catch (Exception $e) {
        // В случае ошибки обновляем статус скана
        $pdo->prepare("
            UPDATE scan_history SET 
                status = 'error', 
                error_message = ?,
                scan_finished_at = CURRENT_TIMESTAMP
            WHERE id = ?
        ")->execute([$e->getMessage(), $currentScanId]);
        
        return [
            'status' => 'error',
            'message' => 'Ошибка при сканировании: ' . $e->getMessage()
        ];
    }
}

?>